---
title: 'Broadcast Changes'
subtitle: 'Trigger broadcast messages from your Database'
description: 'Trigger broadcast messages from your Database'
sidebar_label: 'Broadcast Changes'
---

Let's explore how to implement Realtime Broadcast Changes to trigger messages from your database to your connected users.

<Admonition type="caution">
Realtime Broadcast Changes is in Private Alpha. To use Broadcast Changes request them via Support Ticket.
</Admonition>

<Admonition type="caution">
Realtime Broadcast Changes is in Private Alpha. It's subject to changes both on implementation and usability
</Admonition>

## How it works

Broadcast Changes is our new feature that will allow you to trigger messages from your database. To achieve it we're directly reading your WAL file using a publication against the `realtime.messages` table so whenever a new insert happens we are able to broadcast it to your users.

We are using partitioned tables per day which allows us to delete your previous images in a performant way by dropping the physical tables of this partitioned table. Currently we are dropping tables older than 3 days old.

The broadcast itself uses the same approach as our [Broadcast](https://supabase.com/docs/guides/realtime/broadcast?queryGroups=language&language=js) feature which utilizes WebSockets to send JSON packages. We've also set [Realtime Authorization](https://supabase.com/docs/guides/realtime/authorization?queryGroups=language&language=dart)  as a requirement from the start to ensure connected users comply to your Authorization rules and avoid information leakage.

To help you with this we provide you two functions:

- `realtime.send` that will do the insert into `realtime.messages`
- `realtime.broadcast_changes` that will use `realtime.send` but help you setup the fields required to emit changes to your clients easily.

## Using broadcast changes

### Setup realtime authorization

As mentioned above we've opted to have Realtime Authorization as a requirement so you will need to setup policies for your topics so your users can listen to messages from topics:

```sql
CREATE POLICY "authenticated can receive broadcasts"
ON "realtime"."messages"
FOR SELECT
TO authenticated
USING ( true );

```

Read more about [Realtime Authorization](https://supabase.com/docs/guides/realtime/authorization?queryGroups=language&language=dart) so you ensure you have the best approach for your goal

### Setup trigger function

Then we need to setup the function that will be used by your trigger and this will allow you to setup every element of the message easily.

For our example use case we want to have simply a topic with the name `topic:<record id>` to which we're going to broadcast our event.

```sql
CREATE OR REPLACE FUNCTION public.your_table_changes() RETURNS trigger AS $$
BEGIN
    PERFORM realtime.broadcast_changes(
	    'topic:' || NEW.id::text,   -- topic
		   TG_OP,                          -- event
		   TG_OP,                          -- operation
		   TG_TABLE_NAME,                  -- table
		   TG_TABLE_SCHEMA,                -- schema
		   NEW,                            -- new record
		   OLD                             -- old record
		);
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```

Of note are the Postgres native trigger special variables used:

- `TG_OP` - the operation that triggered the function
- `TG_TABLE_NAME` - the table that caused the trigger
- `TG_TABLE_SCHEMA` - the schema of the table that caused the trigger invocation
- `NEW` - the record after the change
- `OLD` - the record before the change

You can read more about them in this [guide](https://www.postgresql.org/docs/current/plpgsql-trigger.html#PLPGSQL-DML-TRIGGER).
### Setup trigger

With the function ready, we can setup the trigger that will happen on each operation.

```sql
CREATE TRIGGER broadcast_changes_for_your_table_trigger
AFTER INSERT OR UPDATE OR DELETE ON public.your_table
FOR EACH ROW
EXECUTE FUNCTION your_table_changes ();
```

As you can see, we will be broadcasting all operations so our users will receive events when records are inserted, updated or deleted from `public.your_table` .

### Listen on client side

Finally we need to listen for the changes in the client side:

```jsx
const id = '4a8bbe89-f601-4414-bd47-8d0f7ab2a31a'
await supabase.realtime.setAuth() // Needed for Realtime Authorization
const changes = supabase
  .channel(`topic:${gameId}`)
  .on(
    'broadcast',
    { event: 'INSERT' },
    (payload) => console.log(payload)
  )
   .on(
    'broadcast',
    { event: 'UPDATE' },
    (payload) => console.log(payload)
  )
   .on(
    'broadcast',
    { event: 'DELETE' },
    (payload) => console.log(payload)
  )
  .subscribe()
```

## Using it outside of broadcast changes

We wanted to provide you as much flexibility as possible so we have `realtime.send` that will enable you to broadcast messages from your database without a specific format:

```sql
SELECT realtime.send (
	to_jsonb ('{}'::text), -- JSONB Payload
	'event', -- Event name
	'topic', -- Topic
	FALSE -- Public / Private flag
);
```

This allows you to trigger other types of messages that could be useful for other user cases.